"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[531],{3905:function(e,t,r){r.d(t,{Zo:function(){return h},kt:function(){return m}});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var o=a.createContext({}),c=function(e){var t=a.useContext(o),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},h=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),d=c(r),m=n,p=d["".concat(o,".").concat(m)]||d[m]||u[m]||i;return r?a.createElement(p,s(s({ref:t},h),{},{components:r})):a.createElement(p,s({ref:t},h))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,s=new Array(i);s[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:n,s[1]=l;for(var c=2;c<i;c++)s[c]=r[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},8215:function(e,t,r){var a=r(7294);t.Z=function(e){var t=e.children,r=e.hidden,n=e.className;return a.createElement("div",{role:"tabpanel",hidden:r,className:n},t)}},5064:function(e,t,r){r.d(t,{Z:function(){return u}});var a=r(7294),n=r(9443);var i=function(){var e=(0,a.useContext)(n.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=r(6010),l="tabItem_1uMI",o="tabItemActive_2DSg";var c=37,h=39;var u=function(e){var t=e.lazy,r=e.block,n=e.defaultValue,u=e.values,d=e.groupId,m=e.className,p=i(),f=p.tabGroupChoices,g=p.setTabGroupChoices,y=(0,a.useState)(n),b=y[0],v=y[1],k=a.Children.toArray(e.children),w=[];if(null!=d){var x=f[d];null!=x&&x!==b&&u.some((function(e){return e.value===x}))&&v(x)}var S=function(e){var t=e.currentTarget,r=w.indexOf(t),a=u[r].value;v(a),null!=d&&(g(d,a),setTimeout((function(){var e,r,a,n,i,s,l,c;(e=t.getBoundingClientRect(),r=e.top,a=e.left,n=e.bottom,i=e.right,s=window,l=s.innerHeight,c=s.innerWidth,r>=0&&i<=c&&n<=l&&a>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(o),setTimeout((function(){return t.classList.remove(o)}),2e3))}),150))},N=function(e){var t,r;switch(e.keyCode){case h:var a=w.indexOf(e.target)+1;r=w[a]||w[0];break;case c:var n=w.indexOf(e.target)-1;r=w[n]||w[w.length-1]}null==(t=r)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":r},m)},u.map((function(e){var t=e.value,r=e.label;return a.createElement("li",{role:"tab",tabIndex:b===t?0:-1,"aria-selected":b===t,className:(0,s.Z)("tabs__item",l,{"tabs__item--active":b===t}),key:t,ref:function(e){return w.push(e)},onKeyDown:N,onFocus:S,onClick:S},r)}))),t?(0,a.cloneElement)(k.filter((function(e){return e.props.value===b}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},k.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==b})}))))}},9443:function(e,t,r){var a=(0,r(7294).createContext)(void 0);t.Z=a},9420:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return c},contentTitle:function(){return h},metadata:function(){return u},toc:function(){return d},default:function(){return p}});var a=r(7462),n=r(3366),i=(r(7294),r(3905)),s=r(5064),l=r(8215),o=["components"],c={sidebar_position:1},h="Binary Search",u={unversionedId:"algorithms/01BinarySearch",id:"algorithms/01BinarySearch",isDocsHomePage:!1,title:"Binary Search",description:"Binary search is a search algorithm that works on the basis of divide and conquer. The algorithm works on the basis of identifying the middle item in a list and using that to divide the list into two. The process continues until the required value is located.",source:"@site/docs/algorithms/01BinarySearch.md",sourceDirName:"algorithms",slug:"/algorithms/01BinarySearch",permalink:"/dataStructuresAlgorithms/docs/algorithms/01BinarySearch",editUrl:"https://github.com/JKUATSES/dataStructuresAlgorithms/docs/algorithms/01BinarySearch.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Graph \ud83d\udd78\ufe0f",permalink:"/dataStructuresAlgorithms/docs/data-structures/04Graphs"},next:{title:"Sorting",permalink:"/dataStructuresAlgorithms/docs/algorithms/02Sorting"}},d=[{value:"Functonality of Binary Search",id:"functonality-of-binary-search",children:[]},{value:"Recursive Binary Search",id:"recursive-binary-search",children:[]},{value:"Advantages of Binary Search",id:"advantages-of-binary-search",children:[]},{value:"Disadvantages of Binary Search",id:"disadvantages-of-binary-search",children:[]},{value:"Applications of Binary Search",id:"applications-of-binary-search",children:[]},{value:"Implementation of binary search",id:"implementation-of-binary-search",children:[{value:"1. Binary search for an item in a list",id:"1-binary-search-for-an-item-in-a-list",children:[]},{value:"2. Recursive binary search",id:"2-recursive-binary-search",children:[]}]},{value:"What&#39;s next?",id:"whats-next",children:[]}],m={toc:d};function p(e){var t=e.components,c=(0,n.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,c,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"binary-search"},"Binary Search"),(0,i.kt)("p",null,"Binary search is a search algorithm that works on the basis of divide and conquer. The algorithm works on the basis of identifying the middle item in a list and using that to divide the list into two. The process continues until the required value is located. "),(0,i.kt)("p",null,"Condition in the binary search:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The list being searched is already sorted."),(0,i.kt)("li",{parentName:"ul"},"If the list is not sorted, it should be first sorted using a sorting algorithm before searching.")),(0,i.kt)("p",null,"A binary search has a time complexity of O(log n)- Logarithmic time. This means that the list is divided in half every time. Here\u2019s how it works:"),(0,i.kt)("h2",{id:"functonality-of-binary-search"},"Functonality of Binary Search"),(0,i.kt)("p",null,"Binary search begins with a sorted list. From the sorted list, subarrays are created. This begins with the middle value of the list being identfied. The value being searched for is then compared with the middle value. If it is larger than the middle value, the upper half of the list is selected for further analysis. If not, the lower half is selected. This is as illustrated below:"),(0,i.kt)("p",null,"Assumptions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We have a sorted list of a few values between 0 and 50."),(0,i.kt)("li",{parentName:"ul"},"We are looking for the location of 31 in the list.")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Linked List",src:r(50).Z})),(0,i.kt)("p",null,"The position of the mid value is located using the indices of the values where 0 is the lowest index and 9 is the highest. The formula to find the mid is:"),(0,i.kt)("p",null,"mid index = lowest index + (highest index - lowest index)/2             With the answer rounded down."),(0,i.kt)("p",null,"In our case, this yeilds: "),(0,i.kt)("p",null,"mid index = 0 + (9 - 0)/2 = 4.5"),(0,i.kt)("p",null,"Hence, when rounded down, mid index = 4."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Linked List",src:r(9595).Z})),(0,i.kt)("p",null,"The value at the mid index (27), is lower than the value being searched for (31). Therefore, we use the upper half of the list to search for the index of the value."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Linked List",src:r(4182).Z})),(0,i.kt)("p",null,"Our lowest index *in the subarray then becomes mid index + 1 = 5, and the highest index remains 9.\nWe then find the mid index of that new subarray with the same formula which yields:"),(0,i.kt)("p",null,"mid index = 5 + (9 - 5)/2 = 7"),(0,i.kt)("p",null,"We then find the value at index 7."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Linked List",src:r(2708).Z})),(0,i.kt)("p",null,"The value at the mid index (35) is higher than the value being searched for (31). Hence, we use the lower half of the list to search for the index of the value.\nThe highest index in the subarray then becomes the mid index - 1 = 6, and the lowest index remains 5."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Linked List",src:r(5847).Z})),(0,i.kt)("p",null,"The mid index hence, becomes:"),(0,i.kt)("p",null,"mid index = 5 + (6 - 5)/2 = 5.5"),(0,i.kt)("p",null,"Hence, when rounded down, mid index = 5."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Linked List",src:r(6076).Z})),(0,i.kt)("p",null,"Comparing the value at index 5 (31) with the value being searched for (31) reveals that that is the value being searched for. Hence, the answer we get is index 5 as the location of the value 31."),(0,i.kt)("h2",{id:"recursive-binary-search"},"Recursive Binary Search"),(0,i.kt)("p",null,"Binary search, as we have seen, involves a lot of iteration in order to divide the lists into halves and check them . Therefore, a suitable alternative would be the recursive binary search whereby the function uses recursive method calls instead of iterating all through. This is as shown in the code examples.   "),(0,i.kt)("h2",{id:"advantages-of-binary-search"},"Advantages of Binary Search"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Narrows down the search by eliminating half the list after comparison."),(0,i.kt)("li",{parentName:"ul"},"It states whether the item being searched for is before or after the mid position."),(0,i.kt)("li",{parentName:"ul"},"Suitable for large lists.")),(0,i.kt)("h2",{id:"disadvantages-of-binary-search"},"Disadvantages of Binary Search"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Only works on sorted lists."),(0,i.kt)("li",{parentName:"ul"},"It is an overkill for small data sets."),(0,i.kt)("li",{parentName:"ul"},"It is more complicated than linear search.")),(0,i.kt)("h2",{id:"applications-of-binary-search"},"Applications of Binary Search"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Binary search is used to implement features like autocomplete."),(0,i.kt)("li",{parentName:"ul"},"Finding prefixes.")),(0,i.kt)("h2",{id:"implementation-of-binary-search"},"Implementation of binary search"),(0,i.kt)("p",null,"Code examples of finding an item using binary search are as follows:"),(0,i.kt)("h3",{id:"1-binary-search-for-an-item-in-a-list"},"1. Binary search for an item in a list"),(0,i.kt)("p",null,"To select a specific item from a list, the code is as follows:"),(0,i.kt)(s.Z,{defaultValue:"py",values:[{label:"Python",value:"py"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"py",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def binary_search(arr, target):\n    start = 0\n    end = len(arr) -1\n    while start <= end:\n        #find the mid element\n        #int mid = (start + end) / 2; might be possible that (start + end) exceeds the range.\n        mid = start + (end-start)//2\n        if arr[mid] > target:\n            #check in the left side of the array\n            end = mid - 1\n        elif arr[mid]<target:\n            #check in the right side of the array\n            #move the new start to be mid + 1\n            start = mid + 1\n        else:\n            return mid\n\n\n"))),(0,i.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"package com.sly;\n\npublic class BinarySearch {\n\n    public static void main(String[] args) {\n        int[] arr = {-15, -10, -5, 0, 5, 6, 7, 8, 9, 10, 22, 78, 90, 100, 106};\n        int target = 22;\n        int ans = binarySearch(arr, target);\n        System.out.println(ans);\n    }\n\n    // return the index\n    // return -1 if it does not exist\n    static int binarySearch(int[] arr, int target) {\n        int start = 0;\n        int end = arr.length - 1;\n\n        while(start <= end) {\n            // find the middle element\n//            int mid = (start + end) / 2; // might be possible that (start + end) exceeds the range of int in java\n            int mid = start + (end - start) / 2;\n\n            if (target < arr[mid]) {\n                end = mid - 1;\n            } else if (target > arr[mid]) {\n                start = mid + 1;\n            } else {\n                // ans found\n                return mid;\n            }\n        }\n        return -1;\n    }\n}\n\n")))),(0,i.kt)("h3",{id:"2-recursive-binary-search"},"2. Recursive binary search"),(0,i.kt)("p",null,"Using the recursive binary search methos is as illustrated:"),(0,i.kt)(s.Z,{defaultValue:"py",values:[{label:"Python",value:"py"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"py",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def recurssive_binary_search(arr, target, start, end):\n    if start>end:\n        return -1\n\n    mid = start + (end - start)//2\n\n    if arr[mid] == target:\n        return mid\n\n    if arr[start] <= target:\n        if arr[target] >= arr[start] and arr[target] <= arr[mid]:\n            return recurssive_binary_search(arr, target, start, mid-1)\n        else:\n            return recurssive_binary_search(arr, target, mid + 1, end)\n\n\n    if arr[target] >= arr[mid] and arr[target] <= arr[end]:\n        return recurssive_binary_search(arr, target, mid+1, end)\n    return recurssive_binary_search(arr, target, start, mid-1)\n    \nif __name__ == '__main__':\n    arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 38, 90, 101, 3003, 10000]\n    target = 13\n    print(recurssive_binary_search(arr, target, 0, len(arr) -1))\n\n\n"))),(0,i.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"package com.sly;\n\npublic class Recursive_BS {\n    public static void main(String[] args) {\n        int[] arr = {5, 6, 7, 8, 9, 1, 2, 3};\n        System.out.println(search(arr, 4, 0, arr.length - 1));\n    }\n\n    static int search(int[] arr, int target, int start, int end) {\n        if (start > end) {\n            return -1;\n        }\n\n        int mid = start + (end-start) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n\n        if (arr[start] <= arr[mid]) {\n            if (target >= arr[start] && target <= arr[mid]) {\n                return search(arr, target, start, mid-1);\n            } else {\n                return search(arr, target, mid+1, end);\n            }\n        }\n\n        if (target >= arr[mid] && target <= arr[end]) {\n            return search(arr, target, mid+1, end);\n        }\n\n        return search(arr, target, start, mid-1);\n    }\n\n}\n")))),(0,i.kt)("h2",{id:"whats-next"},"What's next?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Check out the leet code ",(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/binary-search/"},"challenge"),"."),(0,i.kt)("li",{parentName:"ul"},"Check out the leet code ",(0,i.kt)("a",{parentName:"li",href:"https://leetcode.com/explore/learn/card/binary-search/"},"content on binary search"),"."),(0,i.kt)("li",{parentName:"ul"},"Check out this python ",(0,i.kt)("a",{parentName:"li",href:"https://realpython.com/binary-search-python/"},"tutorial")),(0,i.kt)("li",{parentName:"ul"},"Check out this java ",(0,i.kt)("a",{parentName:"li",href:"https://www.javatpoint.com/binary-search-in-java"},"tutorial")),(0,i.kt)("li",{parentName:"ul"},"Find inspirations from ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Binary_search_algorithm"},"Wikipedia")),(0,i.kt)("li",{parentName:"ul"},"Get involved in the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/JKUATSES/dataStructuresAlgorithms/"},"JKUAT SES Community"))),(0,i.kt)("p",null,"Anything ",(0,i.kt)("strong",{parentName:"p"},"unclear")," or ",(0,i.kt)("strong",{parentName:"p"},"buggy")," in this tutorial? ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/JKUATSES/dataStructuresAlgorithms/issues"},"Please report it!")))}p.isMDXComponent=!0},6010:function(e,t,r){function a(e){var t,r,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(r=a(e[t]))&&(n&&(n+=" "),n+=r);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function n(){for(var e,t,r=0,n="";r<arguments.length;)(e=arguments[r++])&&(t=a(e))&&(n&&(n+=" "),n+=t);return n}r.d(t,{Z:function(){return n}})},50:function(e,t,r){t.Z=r.p+"assets/images/binarySearchList-6b53ea52fea6dc09a982ff80c8c158a9.png"},5847:function(e,t,r){t.Z=r.p+"assets/images/binarySearchLowerHalf-992e6200ecc4071c60774e9e1c0dc776.png"},6076:function(e,t,r){t.Z=r.p+"assets/images/binarySearchLowerHalfMid-a99a31935ad8d2c58ff1c284191040d8.png"},9595:function(e,t,r){t.Z=r.p+"assets/images/binarySearchMid-08e9c3f7c305d78da241478cc5583244.png"},4182:function(e,t,r){t.Z=r.p+"assets/images/binarySearchUpperHalf-1f1ae966196e5f518457b3e107e0d76c.png"},2708:function(e,t,r){t.Z=r.p+"assets/images/binarySearchUpperHalfMid-af29fcae8adedc2870b200480e14eb6d.png"}}]);